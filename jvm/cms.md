# 并发标记回收
## 1.初始化标记
    此phase会STW(stop the world),初始化标记出所有的GCRoot,为后面的phase提供GCRoot。
## 2.并发标记
    此phase与应用程序，并发执行，提高程序的响应度。
## 3.重新标记
    此phase会STW(stop the world),重新标记。

## 4.并发清理
    些phase 并发清理回收垃圾。

# 并发标记的缺点
    1.浮动垃圾
        在并发清理phase，用户线程仍在运行，在此期间用户线程制造的垃圾就被称为浮动垃圾。
    2.并发失败
        由于浮动垃圾的存在，因此CMS必须预留一部分空间来装载这些新产生的垃圾。如果CMS预留的内存无法容纳浮动垃圾，那么就会导致「并发失败」
    3.内存碎片
        由于CMS采用的是「标记清除」算法，这就意味这清理完成后会在堆中产生大量的内存碎片。


# 三色标记算法
    1.刚开始，所有的对象都是白色，没有被访问。
    2.将GC Roots直接关联的对象置为灰色。
    3.遍历灰色对象的所有引用，灰色对象本身置为黑色，引用置为灰色。
    4.重复步骤3，直到没有灰色对象为止。
    5.结束时，黑色对象存活，白色对象回收。

## 漏标
    a  为GCROOT
    A a = new A()
    //conncurrent
    .....
    a.b = null;
    .....
    // GC 回收
    在回收时实际b是垃圾，但GC认为不是垃圾。
## 错标
    a  为GCROOT,
    A a = new A()
    a.b.c = null;
    //conncurrent
    .....
    a.c = new C()
    .....

# 原始快照和增量更新
    原始快照打破的是第一个条件：当灰色对象指向白色对象的引用被断开时，就将这条引用关系记录下来。当扫描结束后，再以这些灰色对象为根，重新扫描一次。相当于无论引用关系是否删除，都会按照刚开始扫描时那一瞬间的对象图快照来扫描。
    
    增量更新打破的是第二个条件：当黑色指向白色的引用被建立时，就将这个新的引用关系记录下来，等扫描结束后，再以这些记录中的黑色对象为根，重新扫描一次。相当于黑色对象一旦建立了指向白色对象的引用，就会变为灰色对象。



